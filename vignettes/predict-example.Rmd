---
title: "Prediction with BCF"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A Simple Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(bcf2)
```

## Simulate data

First, we simulate some data for testing.  This data set has three covariates $X$, which we divide into two control variables -- that is, variables related to $y$ -- and one effect moderator -- that is, a variable that changes the relationship between $y$ and the treatment effect $\tau$.

We draw the $X$s from a standard normal distribution and generate each unit's outcome, $\mu_i$, as a function of these covariates.  Each unit's probability of joining the intervention, $\pi_i$, is also a function of $\mu_i$, so that units with larger outcomes are more likely to participate in the intervention.  We then assign units to treatment ($z_i = 1$) or comparison ($z_i = 0$) as a function of $\pi_i$.

Then we generate the true treatment effect for each unit, $\tau_i$.  As noted above, $\tau_i$ is a function of $X_3$.  the observed outcome, $y_i$, is a function of $\mu_i$, $\tau_i$, and a random error term $\sigma$.

```{r}
set.seed(1)

p <- 3 # two control variables and one effect moderator
n <- 1000
n_burn <- 100
n_sim <- 150


x <- matrix(rnorm(n*p), nrow=n)

weights <- 1.0*rep(1, n)


# create targeted selection, whereby a practice's likelihood of joining the intervention (pi) is related to their expected outcome (mu)
q <- -1*(x[,1]>(x[,2])) + 1*(x[,1]<(x[,2])) -0.1

# generate treatment variable
pi <- pnorm(q)
z <- rbinom(n,1,pi)

# tau is the true treatment effect. It varies across practices as a function of
# X3, the effect moderator
tau <- (1/(1 + exp(-x[,3])))

mu <- q

# generate the response using q, tau and z
y_noiseless <- mu + tau*z

# set the noise level relative to the expected mean function of Y
sigma <- diff(range(mu + tau*pi))/8

# draw the response variable with additive error
y <- y_noiseless + sigma*rnorm(n)
```

## Fitting BCF

We now fit a BCF model. 

```{r}
out2 <- bcf2::bcf(y               = y,
                  z               = z,
                  x_control       = x,
                  x_moderate      = x,
                  pihat           = pi,
                  nburn           = n_burn,
                  nsim            = n_sim,
                  w               = weights,
                  n_chains        = 2,
                  update_interval = 1)

cat("BCF run complete\n")
```



## Predicting using BCF

We will use the same data as our training set for prediction. 

This will allow us to assess whether BCF predicts accurately.

```{r}
cat("Starting Prediction \n")

pred_out = bcf2::predict(bcf_out=out2,
                         x_predict_control=x,
                         x_predict_moderate=x,
                         pi_pred=pi,
                         z_pred=z,
                         save_tree_directory = '..')

cat("Predictions Complete\n")
```

## Assessing our prediction

We now compute the mean square error and plot our predicted vs expected results.

Recall that in BCF, $\hat{y} = \mu + z*\tau$ .

```{r}
mean_square_error <- function (x,y){
  mean((x-y)^2)
}

assess_pred <- function(x, y, z, title){
  cat("Assessing Cloesness of ", title, "\n")
  print("Correlation")
  print(cor(x,y))
  
  mse = mean_square_error(x,y)
  
  print("MSE")
  print(mse)
  
  print("Error")
  print(sqrt(mse)/abs(mean(x)))
  plot(x, y, col = z + 1, main=title)
  abline(a=0, b=1)
}
```

We first assess our prediction for yhat.

```{r}
assess_pred(colMeans(pred_out$yhat), colMeans(out2$yhat), z, 'yhat')
```

Then for tau.

```{r}
assess_pred(colMeans(pred_out$tau), colMeans(out2$tau), z,'tau')
```

Finally, we assess it for mu.

```{r}
assess_pred(colMeans(pred_out$mu), colMeans(out2$mu), z, 'mu')
```